---
title: "코루틴이란"
date: '2023-09-18'
categories: [ Kotlin, Coroutine ]
---

# 루틴과 코루틴

## 루틴과 코루틴의 차이

- **루틴** : 시작되면 끝날 때 까지 멈추지 않는다. 한 번 끝나면 루틴 내의 정보가 사라진다.
- **코루틴** : 중단되었다가 재개될 수 있다. 중단되더라도 루틴 내의 정보가 사라지지 않는다.

![image](https://github.com/won0935/won0935.github.io/assets/55419159/7bbf077f-4f66-4a21-a3e0-80b994c8e019)

**메모리 관점**에서는 새로운 루틴이 호출된 후 완전히 종료되기 전, 해당 루틴에서 사용했던 정보들을 보관하고 있어야 함

**루틴이 중단되었다가 해당 메모리에 접근이 가능함**

## 인텔리제이 코루틴 디버깅

- `-Dkotlinx.coroutines.debug` 옵션을 주면 어떤 코루틴에서 출력이 일어났는지 확인할 수 있음

![image](https://github.com/won0935/won0935.github.io/assets/55419159/47341f01-686f-4ab3-a338-19018417b553)

```shell
[main @coroutine#1] START
[main @coroutine#1] END
[main @coroutine#2] 3
```

# 스레드와 코루틴

- 스레드 : 프로세스보다 작은 개념, **하나의 프로세스**에 소속되어 여러 코드를 동시에 실행할 수 있게 해준다
- 코루틴 : 스레드보다 더 작은 개념, But **여러 쓰레드**를 사용할 수 있다

| 스레드                                   | 코루틴                                                 |
|---------------------------------------|-----------------------------------------------------|
| 프로세스보다 작은 개념이다.                       | 스레드보다 작은 개념이다.                                      |
| 한 스레드는 오직 한 프로세스에만 포함되어 있다.           | 한 코루틴의 코드는 여러 스레드에서 실행될 수 있다.                       |
| context swithcing 발생시 stack 영역이 교체된다. | (한 스레드에서 실행하는 경우) context switching 발생시 메모리 교체가 없다. |
| OS가 스레드를 강제로 멈추고 다른 스레드를 실행한다.        | 코루틴 스스로가 다른 코루틴에게 양보한다.                             |

## Context Switching 관점에서의 차이

- 프로세스 : 모든 메모리가 교체되므로 비용이 많이 발생한다.
- 쓰레드 : Heap 메모리를 공유하고, Stack만 교체되므로 프로세스보다는 비용이 적다.
- 코루틴 : 동일 스레드에서 코루틴이 실행되면, 메모리 전부를 공유하므로 스레드보다 context switching cost가 낮다.

## 동시성 & 병렬성

즉, 코루틴을 사용하면 하나의 스레드에서도 **동시성**을 확보할 수 있다.

- 동시성 : 한 번에 한 가지 일만 할 수 있지만 아주 빠르게 작업이 전환되어 동시에 하는 것처럼 보이는 것
- 병렬성 : 여러 작업을 동시에 실행하는 것
